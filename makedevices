#!/usr/local/bin/python3
# 
# ElectraOne 
#
# Ableton Live MIDI Remote Script for the Electra One
#
# makedevices: a script to make Devices.py and to prepare the
#   files in xot/ableton for upload to the E1
#
# Author: Jaap-henk Hoepman (info@xot.nl)
#
# Distributed under the MIT License, see LICENSE

from pathlib import Path
import os
import json

from versioninfo import COMMITDATE

PREAMBLE = """
# ElectraOne - Device definitions
#
# (THIS IS FILE IS AUTOGENERATED, DO NOT EDIT!)
#
# Ableton Live MIDI Remote Script for the Electra One
#
# Author: Jaap-henk Hoepman (info@xot.nl)
#
# Distributed under the MIT License, see LICENSE
#

from .ElectraOneBase import ElectraOneBase

from .PresetInfo import PresetInfo
from .CCInfo import CCMap

# Dictionary with preset and MIDI cc mapping data for known devices
# (indexed by device.original_name)
# - The preset is a JSON string in Electra One format.
#   (The current implementation assumes that all quantized parameters
#   are 7-bit absolute CC values while all non quantized parameters are
#   14-bit absolute values)
# - The LUA script is a string, possibly empty
# - The MIDI cc mapping data is a dictionary of Ableton Live original parameter
#   names with their corresponding MIDI CCInfo values (as ordinary tuples)
#   in the preset. The CCInfo data must match the info in the preset used for
#   the same parameter.

"""

POSTSCRIPT = """
# Return the predefined preset information for a device, None if it doesn't exist
# Tries to find Live version specific presets for a device, so returns
# also the version specific name if found
def get_predefined_preset_info(device_name):
    # FIXME: try to read from file
    # try loading version specific definitions
    # e.g. Echo.12.0 or Echo.12
    if device_name in DEVICES:
        presets = DEVICES[device_name]
        versions = list(presets.keys())
        versions.sort()
        i = 0
        # versions[0]=(0,0,0) always
        while (i < len(versions)) and (versions[i] <= ElectraOneBase.LIVE_VERSION):
            i += 1
        assert i > 0, 'Empty preset dict encountered.'
        return presets[versions[i-1]]
    else:
        return (None,None)
"""

# Output file
DEVICES_FILE = 'Devices.py'

# Path to file containing the default LUA script that always needs to be
# included
DEFAULT_LUA_SCRIPT_FILE  = 'default.lua'

# Dictionary of device presets to construct and dump

DEVICES = {}

def extract_version_from_name(device_versioned_name):
    """Return a tuple (name, version-3-tuple)
    """
    extended_name = device_versioned_name + '.0.0.0' # make sure enough version fields exist
    splits = extended_name.rsplit('.')
    return (splits[0] , (int(splits[1]),int(splits[2]),int(splits[3])))

def process_preset(preset_path):
    """Process one preset, storing its data in DEVICES
    """
    json_preset_path = preset_path
    lua_script_path = preset_path.with_suffix('.lua')
    ccmap_path = preset_path.with_suffix('.ccmap')
    device_versioned_name = preset_path.stem
    (device_name,version) = extract_version_from_name(device_versioned_name)
    if device_name not in DEVICES:
        DEVICES[device_name]={}
    print(f'Predefining {device_name} ({device_versioned_name}) for Live version {version} or higher.')
    # load and process the .epr preset
    with open(json_preset_path,'r') as inf:
        #print('- Loading preset JSON.')
        json_load = json.load(inf)
        json_preset = json.dumps(json_load, separators=(',', ':'))
        # escape single quotes in json_preset; it will be written
        # as a single-quoted string to Devices.py
        filter_quotes = str.maketrans({ "'": "\\'"})
        filtered_json_preset = json_preset.translate(filter_quotes)
    # load the .lua script if it exist
    lua_script = ""
    # append the .lua if it exists
    if os.path.exists(lua_script_path):
        with open(lua_script_path,'r') as inf:
            #print('- LUA script found. Loading.')
            lua_script += inf.read()
    # escape single quotes in json_preset; it will be written
    # as a single-quoted string to Devices.py
    filter_quotes = str.maketrans({ "'": "\\'"})
    filtered_lua_script = lua_script.translate(filter_quotes)
    # load the .ccmap
    with open(ccmap_path,'r') as inf:
        #print('- Loading CCMAP.')
        ccmap = inf.read()
        # Remove newlines from ccmap
        # TODO: commented out to allow comments in CC-maps
        #filter_newlines = str.maketrans({ '\n': None})
        #ccmap = ccmap.translate(filter_newlines)
    preset_info = (filtered_json_preset,filtered_lua_script,ccmap)
    preset = (device_versioned_name,preset_info)
    DEVICES[device_name][version]=preset

def dump_preset(outf,preset):
    # write the preset information to DEVICES.py
    (device_name,preset_info) = preset
    (json,lua,ccmap) = preset_info
    outf.write(f"('{ device_name }', PresetInfo('")
    outf.write(json)
    outf.write("',\n    ")
    # LUA script may contain newlines
    outf.write('"""')
    outf.write(lua)
    outf.write('""",\n    ')
    outf.write(f'CCMap({ccmap})')
    outf.write('))')

def dump_device(outf,device):
    inner_flag = False
    outf.write('{')
    for preset_version in device.keys():
        # write a comma to outf if needed
        if inner_flag:
            outf.write(',\n')
        inner_flag = True
        outf.write(f"{preset_version}:")
        dump_preset(outf,device[preset_version])
    outf.write('}')
               
def dump_devices(outf):
    """Dump all devices in DEVICES to outf
    """
    outer_flag = False
    outf.write('DEVICES = {\n')
    for device_name in DEVICES.keys():
        # write a comma to outf if needed
        if outer_flag:
            outf.write(',\n')
        outer_flag = True
        outf.write(f"'{ device_name }':")
        dump_device(outf,DEVICES[device_name])
    outf.write('\n}\n')

# === MAIN ===

print(f'MAKEDEVICES (version of {COMMITDATE}): fill ./Devices.py with presets in ./preloaded')
# load the defualt lua script
if os.path.exists(DEFAULT_LUA_SCRIPT_FILE):
    with open(DEFAULT_LUA_SCRIPT_FILE,'r') as inf:
        DEFAULT_LUA_SCRIPT = inf.read()
else:
    print('ERROR: file ./defualt.lua does not exist.')
    print('-> run this script in the root of the remote script directory.')
    exit()
if not os.path.exists('preloaded'):
    print('ERROR: folder ./preloaded does not exist.')
    print('-> run this script in the root of the remote script directory.')
    exit()
# find the paths to all presets to preload
here = Path('.')
allpresets_paths = here.glob('preloaded/*.epr')
# process each preset path and store in DEVICES
for preset_path in allpresets_paths:
    process_preset(preset_path)
# open the output for writing and dump DEVICES
with open(DEVICES_FILE,'w') as outf:
    outf.write(PREAMBLE)
    outf.write(f'\nDEFAULT_LUA_SCRIPT="""{DEFAULT_LUA_SCRIPT}"""\n\n')
    dump_devices(outf)
    outf.write('\n')
    outf.write(POSTSCRIPT)
